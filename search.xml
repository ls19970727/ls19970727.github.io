<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>牛客题解-NC37合并区间</title>
    <url>/2020/06/22/2020622-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC37/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一组区间，请合并所有重叠的区间。</p>
<p>请保证合并后的区间按区间起点升序排列。</p>
<p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">10</span>,<span class="number">30</span>],[<span class="number">20</span>,<span class="number">60</span>],[<span class="number">80</span>,<span class="number">100</span>],[<span class="number">150</span>,<span class="number">180</span>]]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">10</span>,<span class="number">60</span>],[<span class="number">80</span>,<span class="number">100</span>],[<span class="number">150</span>,<span class="number">180</span>]]</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>利用<code>Collections.sort()</code>方法对每一个区间的左区间进行排序，然后从第一个序列进行遍历，当后一个区间的右区间，小于或者等于后一个区间的左区间时，然后继续遍历下一个区间的左区间，并与下下个区间的右区间继续比较……直到后一个左区间大于后一个的右区间时，合并前面的多个区间，并寻找下一个合并区间，直到结束。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.sort(intervals,(a,b)-&gt;a.start-b.start);</span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals.get(i).start;</span><br><span class="line">            <span class="keyword">int</span> right = intervals.get(i).end;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len-<span class="number">1</span> &amp;&amp; intervals.get(i+<span class="number">1</span>).start &lt;= right) &#123;</span><br><span class="line">                right = Math.max(right,intervals.get(i+<span class="number">1</span>).end);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> Interval(left,right));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC54数组中相加和为0三元组</title>
    <url>/2020/06/24/2020623-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC54%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E5%8A%A0%E5%92%8C%E4%B8%BA0%E4%B8%89%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。</p>
<p>注意：</p>
<ol>
<li><p>三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）</p>
</li>
<li><p>解集中不能包含重复的三元组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如，给定的数组 S = &#123;-<span class="number">10</span> <span class="number">0</span> <span class="number">10</span> <span class="number">20</span> -<span class="number">10</span> -<span class="number">40</span>&#125;,解集为(-<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>) (-<span class="number">10</span>, -<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[-<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>],[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过Arrays.sort()方法对原数组进行排序，对于排序后的数据，从第一个元素开始，运用双指针（首尾双指针），求解该双指针指向数字之和为当前索引所在数字的相反数即可。实际上就转换成了多次的双指针求和问题。</p>
<p>需要特别注意的是在每一次指针移动过程中要判断是否有重复元素，重复元素需要跳过。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> ||num.length &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num.length-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = num.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = num[i] + num[l] + num[r];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tmp.add(num[i]);</span><br><span class="line">                    tmp.add(num[l]);</span><br><span class="line">                    tmp.add(num[r]);</span><br><span class="line">                    res.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r &amp;&amp; num[l] == num[l+<span class="number">1</span>])&#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r &amp;&amp; num[r] == num[r-<span class="number">1</span>])&#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC61两数之和</title>
    <url>/2020/06/23/2020623-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC61%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给出一个整数数组，请在数组中找出两个加起来等于目标值的数，</p>
<p>你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的</p>
<p>假设给出的数组中只存在唯一解</p>
<p>例如：</p>
<p>给出的数组为 {20, 70, 110, 150},目标值为90<br>输出 index1=1, index2=2</p>
<p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>],<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目提到只存在唯一解，故而考虑使用HashMap求解该问题。</p>
<p>对于每一个数，在存入HashMap之前先判断HashMap中当前是否存在可以和该数字相加为target的数字，有则返回。没有才将该数字和下标存入HashMap中。先判断后存入的方式能够避免使用到同一个数字。</p>
<p>要注意返回时下标需要+1.</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum (<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-numbers[i]))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(target-numbers[i])+<span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">             map.put(numbers[i],i);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC65斐波那契数列</title>
    <url>/2020/06/24/2020624-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC65%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<p><em>n</em>≤39</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该问题为经典的动态规划问题。</p>
<p>对于动态规划问题，关键就是找到初始状态和状态转换方程。</p>
<p>本体的初始状态为</p>
<p>f（0）= 0</p>
<p>f（1）= 1</p>
<p>状态转换方程为</p>
<p>f（n） = f（n-1）+ f（n-2）</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC144不相邻最大子序列和</title>
    <url>/2020/06/25/2020625-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC144%E4%B8%8D%E7%9B%B8%E9%82%BB%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个n（1≤<em>n</em>≤1e5)，和一个长度为n的数组，在不同时选位置相邻的两个数的基础上，求该序列的最大子序列和（挑选出的子序列可以为空）。</p>
<p>注意：</p>
<ol>
<li><p>三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）</p>
</li>
<li><p>解集中不能包含重复的三元组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如，给定的数组 S = &#123;-<span class="number">10</span> <span class="number">0</span> <span class="number">10</span> <span class="number">20</span> -<span class="number">10</span> -<span class="number">40</span>&#125;,解集为(-<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>) (-<span class="number">10</span>, -<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">有[],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>] <span class="number">4</span>种选取方式其中[<span class="number">1</span>,<span class="number">3</span>]选取最优，答案为<span class="number">4</span> </span><br></pre></td></tr></table></figure>



<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>,[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其中[<span class="number">4</span>,<span class="number">5</span>]的选取方案是在满足不同时选取相邻位置的数的情况下是最优的答案 </span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该问题为动态规划问题。</p>
<p>用一个长度为n+1的数组dp[n+1]来保存各个位置的最佳解。</p>
<p>首先初始化dp[0] = 0; dp[1] =  array[0];</p>
<p>后续具体的状态转移过程可以描述为：</p>
<p>dp[i] = Math.max(dp[i-1], dp[i-2] + array[i-1])</p>
<p>最终得到的dp[n]则为所求解。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 数组的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 长度为n的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">subsequence</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+array[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC66两个链表的第一个公共节点</title>
    <url>/2020/06/25/2020625-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC66%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从两个链表的头节点出发，同时向后移动，当某一个链表的指针为空后，此时到了链表尾，指向另一个链表的头节点，这样，最终两个指针会在两个链表的同一相对位置。此时继续遍历就能找到第一个公共节点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210325194213.png"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="keyword">null</span> || pHead2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode l1 = pHead1;</span><br><span class="line">        ListNode l2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != l2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) l1 = pHead2;</span><br><span class="line">                <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) l2 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC1大数加法</title>
    <url>/2020/06/27/2020627-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC1%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。</p>
<p>（字符串长度不大于100000，保证字符串仅由’0’~’9’这10种字符组成）</p>
<p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;99&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">99</span>=<span class="number">100</span> </span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该题目重点在于获取当前栈中的min值。</p>
<p>考虑为原栈stack1，新建一个stack2栈用来维持stack1中的最小数。由于栈FILO的特性，只需要保证stack2中的栈顶元素维持在一个最小值水平即可。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算两个数之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : s.charAt(i--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : t.charAt(j--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            sb.append(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC90设计getMin功能的栈</title>
    <url>/2020/06/26/2020626-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC90%E8%AE%BE%E8%AE%A1getMin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1,3],[1,2],[1,1],[3],[2],[3]]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2]</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有三种操作种类，op1表示push，op2表示pop，op3表示getMin。你需要返回和op3出现次数一样多的数组，表示每次getMin的答案</span><br><span class="line"></span><br><span class="line">1&lt;=操作总数&lt;=1000000</span><br><span class="line">-1000000&lt;=每个操作数&lt;=1000000</span><br><span class="line">数据保证没有不合法的操作</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该题目重点在于获取当前栈中的min值。</p>
<p>考虑为原栈stack1，新建一个stack2栈用来维持stack1中的最小数。由于栈FILO的特性，只需要保证stack2中的栈顶元素维持在一个最小值水平即可。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return a array which include all ans for op3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> op int整型二维数组 operator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMinStack (<span class="keyword">int</span>[][] op) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;op.length; i++)&#123;</span><br><span class="line">            flag = op[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                s1.push(op[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(s2.isEmpty() || s2.peek() &gt;= op[i][<span class="number">1</span>])&#123;</span><br><span class="line">                    s2.push(op[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> value = s1.pop();</span><br><span class="line">                <span class="keyword">if</span>(value == s2.peek())&#123;</span><br><span class="line">                    s2.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123;</span><br><span class="line">                list.add(s2.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;list.size(); j++)&#123;</span><br><span class="line">            res[j] = list.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC15求二叉树的层序遍历</title>
    <url>/2020/06/28/2020628-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC15%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br>例如：<br>给定的二叉树是{3,9,20,#,#,15,7},</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210325202139.png"></p>
<p>该二叉树层序遍历的结果是<br>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>],[<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>



<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,#,#,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure>





<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>bfs问题借助队列FIFO的特性。</p>
<p>逐层遍历二叉树，在某一层进行遍历的时候。写入遍历信息到ArrayList集合中去的同时，判断每个节点是否存在左右子树。存在的话将对应的子节点入队。以准备下一层次的遍历。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                TreeNode tmp = queue.poll();</span><br><span class="line">                level.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>) queue.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>) queue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC17最长回文子串</title>
    <url>/2020/06/28/2020628-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC17%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。</p>
<p>给定字符串<strong>A</strong>以及它的长度<strong>n</strong>，请返回最长回文子串的长度。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abc1234321ab&quot;</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210327210613.png"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLongestPalindrome</span><span class="params">(String A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l;</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = (A.charAt(i) == A.charAt(j));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = (dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; A.charAt(i) == A.charAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; ans.length())&#123;</span><br><span class="line">                    ans = A.substring(i,i+l+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC73数组中超过一半的数字（众数）</title>
    <url>/2020/06/28/2020628-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC73%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E4%BC%97%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><strong>思路</strong>：用一般的排序也可以完成这道题目，但是如果那样完成的话就可能太简单了。<br>用preValue记录上一次访问的值，count表明当前值出现的次数，如果下一个值和当前值相同那么count++；如果不同count–，减到0的时候就要更换新的preValue值了，因为如果存在超过数组长度一半的值，那么最后preValue一定会是该值。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>||array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == tmp)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp = array[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == tmp)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; array.length/<span class="number">2</span>) res = tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC3链表中环的入口节点</title>
    <url>/2020/06/29/2020629-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC3%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>对于一个给定的链表，返回环的入口节点，如果没有环，返回null</p>
<p>拓展：</p>
<p>你能给出不利用额外空间的解法么？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>利用快慢指针确定链表是否存在环。</p>
<p>是：此时的slow指针和fast指针相遇且均在环内。此时将另一个指针slow2指向链表头结点，并让slow2和slow指针同时一次移动一步。由于slow指针在环内，所以两节点一旦相遇。一定是在环的入口节点处。</p>
<p>否：返回null。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                <span class="keyword">while</span>(slow2 != slow)&#123;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC141判断回文</title>
    <url>/2020/07/01/202071-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC141%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串，请编写一个函数判断该字符串是否回文。如果回文请返回true，否则返回false。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;absba&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;ranko&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;yamatomaya&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>tips:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">字符串长度不大于<span class="number">1000000</span>，且仅由小写字母组成</span><br></pre></td></tr></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>直接利用双索引，从第一个下标i和最后一个下标j开始比较，此后i++和j–逐一比较。直到遇到不同的字符则返回false，否则返回true。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = str.length()-<span class="number">1</span>; i&lt;j; i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) != str.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC25删除有序链表中重复的元素</title>
    <url>/2020/07/01/202071-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC25%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1\to1\to21→1→2,返回1 \to 21→2.<br>给出的链表为1\to1\to 2 \to 3 \to 31→1→2→3→3,返回1\to 2 \to 31→2→3.</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用一个指针就可以实现，对指针当前位置和下一位置的值进行比较。</p>
<p>相同：删除下一位置的节点</p>
<p>不同：指针移动到下一位置</p>
<p>直到链表尾。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp.next.val == tmp.val)&#123;</span><br><span class="line">                tmp.next = tmp.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC38螺旋矩阵</title>
    <url>/2020/07/01/202071-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC38%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210325212049.png"></p>
<p>分别需要实现四个遍历：</p>
<p>左→右</p>
<p>上→下</p>
<p>右→左</p>
<p>下→上</p>
<p>需要特别注意的是不要遍历重复数据。left、right、top、bottom的指针变化方式尤为重要。</p>
<p>另外还要注意限制条件top！= bottom 和 left！= right</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210325212338.png"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &lt; (matrix.length + <span class="number">1</span>) / <span class="number">2</span> &amp;&amp; left &lt; (matrix[<span class="number">0</span>].length + <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left &amp;&amp; top != bottom; i--)&#123;</span><br><span class="line">                res.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt;= top + <span class="number">1</span> &amp;&amp; left != right; i--)&#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            top++;</span><br><span class="line">            right--;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC69链表中倒数第k个节点</title>
    <url>/2020/07/01/202071-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC69%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>如果该链表长度小于k，请返回空。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,<span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先让一个指针first先走k步。</p>
<p>此时再引出一个res指针从head节点开始。</p>
<p>first 和res 指针同时前进。</p>
<p>当first走到尾部时，此时res为倒数第k个节点。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode first = pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = pHead;</span><br><span class="line">        <span class="keyword">while</span>(first != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res = res.next;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习日记（二）远程仓库与分支管理</title>
    <url>/2020/07/22/2020722-Git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<font size = 3>

<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p><a href="https://github.com/">GitHub</a>提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。</p>
<p>在Repository name填入仓库名（<code>learngit</code>），其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:xxxxxx/learngit.git</span><br></pre></td></tr></table></figure>

<p>请千万注意，把上面的xxxxxx替换成你自己的GitHub账户名</p>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: <span class="number">20</span>, done.</span><br><span class="line">Delta compression using up to <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">20</span>/<span class="number">20</span>), <span class="number">1.64</span> KiB | <span class="number">560.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">20</span> (delta <span class="number">5</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: Resolving deltas: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> set up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<h2 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h2><h3 id="删除远程库-1"><a href="#删除远程库-1" class="headerlink" title="删除远程库"></a>删除远程库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git<span class="meta">@github</span>.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git<span class="meta">@github</span>.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure>

<p>然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure>

<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>用命令<code>git clone</code>克隆一个本地库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git clone git<span class="meta">@github</span>.com:xxxxxx/gitskills.git</span><br><span class="line">Cloning into <span class="string">&#x27;gitskills&#x27;</span>...</span><br><span class="line">remote: Counting objects: <span class="number">3</span>, done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">3</span></span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br></pre></td></tr></table></figure>

<p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>



<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416205416.png"></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416205445.png"></p>
<p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416205540.png"></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416205611.png"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416211709.png"></p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch is quick.</span><br></pre></td></tr></table></figure>

<p>然后提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;branch test&quot;</span></span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416211652.png"></p>
<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch -<span class="function">d dev</span></span><br><span class="line"><span class="function">Deleted branch <span class="title">dev</span> <span class="params">(was b17d20e)</span>.</span></span><br></pre></td></tr></table></figure>

<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> -c dev</span><br></pre></td></tr></table></figure>

<p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> master</span><br></pre></td></tr></table></figure>

<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> -c feature1</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">&#x27;feature1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch is quick AND simple.</span><br></pre></td></tr></table></figure>

<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;AND simple&quot;</span></span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>切换到<code>master</code>分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by <span class="number">1</span> commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your local commits)</span><br></pre></td></tr></table></figure>

<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch is quick &amp; simple.</span><br></pre></td></tr></table></figure>

<p>提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;&amp; simple&quot;</span></span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416211632.png"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.<span class="function">txt</span></span><br><span class="line"><span class="function"><span class="title">CONFLICT</span> <span class="params">(content)</span>: Merge conflict in readme.txt</span></span><br><span class="line"><span class="function">Automatic merge failed</span>; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by <span class="number">2</span> commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   readme.<span class="function">txt</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">no changes added to <span class="title">commit</span> <span class="params">(use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a <span class="keyword">new</span> branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>

<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch is quick and simple.</span><br></pre></td></tr></table></figure>

<p>再提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;conflict fixed&quot;</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416211809.png"></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>

<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git branch -<span class="function">d feature1</span></span><br><span class="line"><span class="function">Deleted branch <span class="title">feature1</span> <span class="params">(was 14096d0)</span>.</span></span><br></pre></td></tr></table></figure>

<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> -c dev</span><br><span class="line">Switched to a <span class="keyword">new</span> branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改readme.txt文件，并提交一个新的commit：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;add merge&quot;</span></span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>

<p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416212421.png"></p>
<h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416213422.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC135股票（两次交易）</title>
    <url>/2020/07/03/202073-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC135%E8%82%A1%E7%A5%A8%EF%BC%88%E4%B8%A4%E6%AC%A1%E4%BA%A4%E6%98%93%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假定你知道某只股票每一天价格的变动。</p>
<p>你最多可以同时持有一只股票。但你最多只能进行<strong>两次</strong>交易（一次买进和一次卖出记为一次交易。买进和卖出均无手续费）。</p>
<p>请设计一个函数，计算你所能获得的最大收益。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>tips：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第三天买进，第四天卖出，第五天买进，第六天卖出。总收益为<span class="number">4</span>。 </span><br><span class="line">总天数不大于<span class="number">200000</span>。保证股票每一天的价格在[<span class="number">1</span>,<span class="number">100</span>]范围内。</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该问题为动态规划问题，关键在于找到初始值以及动态规划转移方程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326215805.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326215841.png"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210326215918814.png" alt="image-20210326215918814"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 两次交易所能获得的最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -<span class="number">1</span> * prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -<span class="number">1</span> * prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">4</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习日记（一）安装与时光机</title>
    <url>/2020/07/22/2020722-Git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E6%97%B6%E5%85%89%E6%9C%BA/</url>
    <content><![CDATA[<font size = 3>

<h1 id="windows下的安装"><a href="#windows下的安装" class="headerlink" title="windows下的安装"></a>windows下的安装</h1><p>下载安装</p>
<p>安装完成后配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>首先，选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit<span class="comment">//创建目录</span></span><br><span class="line">$ cd learngit<span class="comment">//切换到刚刚创建的目录下</span></span><br><span class="line">$ pwd<span class="comment">//显示当前所在目录</span></span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>

<h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure>

<p>目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h2 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h2><p>对于文件编码，如果没有历史遗留问题，强烈建议使用标准的<strong>UTF-8</strong>编码</p>
<p>不要使用windows子代记事本，下载<a href="http://notepad-plus-plus.org/">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可。</p>
<p>在任意位置创建一个txt（readme.txt），添加文本内容。</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>

<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> readme.txt</span><br></pre></td></tr></table></figure>

<p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m <span class="string">&quot;add 3 files.&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="时光穿梭"><a href="#时光穿梭" class="headerlink" title="时光穿梭"></a>时光穿梭</h1><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看。</p>
<p>要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>

<p>指定回到未来的某个版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>

<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;<span class="number">1</span>&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;<span class="number">2</span>&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;<span class="number">3</span>&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;<span class="number">4</span>&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>

<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416202617.png"></p>
<p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>tips：用<code>git status</code>查看一下状态</p>
<h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><p><code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>

<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p><strong>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</strong></p>
<p>用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	readme.txt</span><br></pre></td></tr></table></figure>

<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。 </p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add test.txt&quot;</span></span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br><span class="line"> create mode <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure>

<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure>

<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test.<span class="function">txt</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">no changes added to <span class="title">commit</span> <span class="params">(use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> deletion(-)</span><br><span class="line"> delete mode <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure>

<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC62平衡二叉树</title>
    <url>/2020/07/03/202073-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC62%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>利用递归逐层判断左右子树深度只差是否超过1。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left - right &lt; (-<span class="number">1</span>) || left - right &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (left &gt; right ? left:right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC92最长公共子序列</title>
    <url>/2020/07/03/202073-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC92%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1A2C3D4B56&quot;</span>,<span class="string">&quot;B1D23CA45B6A&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>tips：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1≤∣str 1∣,∣str 2∣≤5000</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先需要科普一下，最长公共子序列（longest common sequence）和最长公共子串（longest common substring）不是一回事儿。什么是子序列呢？即一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。什么是子串呢？给定串中任意个连续的字符组成的子序列称为该串的子串。给一个图再解释一下：<br><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210329200226.png"></p>
<p>   求解LCS问题，不能使用暴力搜索方法。一个长度为n的序列拥有 2的n次方个子序列，它的时间复杂度是指数阶，太恐怖了。解决LCS问题，需要借助动态规划的思想。<br>       动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。</p>
<p>解决LCS问题，需要把原问题分解成若干个子问题，所以需要刻画LCS的特征。</p>
<p>   设A=“a0，a1，…，am”，B=“b0，b1，…，bn”，且Z=“z0，z1，…，zk”为它们的最长公共子序列。不难证明有以下性质：<br>   如果am=bn，则zk=am=bn，且“z0，z1，…，z(k-1)”是“a0，a1，…，a(m-1)”和“b0，b1，…，b(n-1)”的一个最长公共子序列；<br>   如果am!=bn，则若zk!=am，蕴涵“z0，z1，…，zk”是“a0，a1，…，a(m-1)”和“b0，b1，…，bn”的一个最长公共子序列；<br>   如果am!=bn，则若zk!=bn，蕴涵“z0，z1，…，zk”是“a0，a1，…，am”和“b0，b1，…，b(n-1)”的一个最长公共子序列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210329200311.png"></p>
<p>  假如S1的最后一个元素 与 S2的最后一个元素相等，那么S1和S2的LCS就等于 {S1减去最后一个元素} 与 {S2减去最后一个元素} 的 LCS  再加上 S1和S2相等的最后一个元素。</p>
<p>   假如S1的最后一个元素 与 S2的最后一个元素不等（本例子就是属于这种情况），那么S1和S2的LCS就等于 ： {S1减去最后一个元素} 与 S2 的LCS， {S2减去最后一个元素} 与 S1 的LCS 中的最大的那个序列。</p>
<p>假设我需要求 a1 … am 和 b1 .. b(n-1)的LCS 和 a1 … a(m-1) 和 b1 .. bn的LCS，一定会递归地并且重复地把如a1… a(m-1) 与 b1 … b(n-1) 的 LCS 计算几次。所以我们需要一个数据结构来记录中间结果，避免重复计算。</p>
<p>​    假设我们用c[i,j]表示Xi 和 Yj 的LCS的长度（直接保存最长公共子序列的中间结果不现实，需要先借助LCS的长度）。其中X = {x1 … xm}，Y ={y1…yn}，Xi = {x1 … xi}，Yj={y1… yj}。可得递归公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210329200424.png"></p>
<p> 本文S1和S2的最LCS并不是只有1个，本文并不是着重讲输出两个序列的所有LCS，只是介绍如何通过上表，输出其中一个LCS。</p>
<p>   我们根据递归公式构建了上表，我们将从最后一个元素c[8][9]倒推出S1和S2的LCS。</p>
<p>   c[8][9] = 5，且S1[8] != S2[9]，所以倒推回去，c[8][9]的值来源于c[8][8]的值(因为c[8][8] &gt; c[7][9])。</p>
<p>   c[8][8] = 5,  且S1[8] = S2[8], 所以倒推回去，c[8][8]的值来源于 c[7][7]。</p>
<p>   以此类推，如果遇到S1[i] != S2[j] ，且c[i-1][j] = c[i][j-1] 这种存在分支的情况，这里请都选择一个方向（之后遇到这样的情况，也选择相同的方向）。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * longest common subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> l1 = s1.length(), l2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span>||s2 == <span class="keyword">null</span>|| s1 == <span class="string">&quot;&quot;</span> || s2 == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[l1 + <span class="number">1</span>][l2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l1; i++) &#123;dp[i][<span class="number">0</span>] = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= l2; j++) &#123;dp[<span class="number">0</span>][j] = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="number">0</span> &amp;&amp; l2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(l1-<span class="number">1</span>) == s2.charAt(l2 - <span class="number">1</span>))&#123;</span><br><span class="line">                sb.append(s1.charAt(l1-<span class="number">1</span>));</span><br><span class="line">                l1 --;</span><br><span class="line">                l2 --;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[l1 - <span class="number">1</span>][l2] &gt; dp[l1][l2-<span class="number">1</span>])&#123;</span><br><span class="line">                    l1--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l2--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC8二叉树路径之和</title>
    <url>/2020/07/04/202074-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树和一个值\ sum <em>s<strong>u</strong>m</em>，请找出所有的根节点到叶子节点的节点值之和等于\ sum <em>s<strong>u</strong>m</em> 的路径，<br>例如：<br>给出如下的二叉树，\ sum=22 <em>s<strong>u</strong>m</em>=22，</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326221631.png"></p>
<p>返回<br>[<br>[5,4,11,2],<br>[5,8,9]<br>]</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326221753.png"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathSum (TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        dfs(root, sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        cur += root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dfs(root.left, sum, cur);</span><br><span class="line">                dfs(root.right, sum, cur);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC134股票（无限次交易）</title>
    <url>/2020/07/04/202074-%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC134%E8%82%A1%E7%A5%A8%EF%BC%88%E6%97%A0%E9%99%90%E6%AC%A1%E4%BA%A4%E6%98%93%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假定你知道某只股票每一天价格的变动。</p>
<p>你最多可以同时持有一只股票。但你可以无限次的交易（买进和卖出均无手续费）。</p>
<p>请设计一个函数，计算你所能获得的最大收益。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>tips：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于每天股票都在跌，因此不进行任何交易最优。最大收益为<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>tips：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一天买进，最后一天卖出最优。中间的当天买进当天卖出不影响最终结果。最大收益为<span class="number">4</span>。  </span><br><span class="line">总天数不大于<span class="number">200000</span>。保证股票每一天的价格在[<span class="number">1</span>,<span class="number">100</span>]范围内。</span><br></pre></td></tr></table></figure>



<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义dp[i][0]表示第i+1天交易完之后手里没有股票的最大利润，dp[i][1]表示第i+1天交易完之后手里持有股票的最大利润。</span><br></pre></td></tr></table></figure>



<p><strong>当天交易完之后手里没有股票可能有两种情况，一种是当天没有进行任何交易</strong>，又因为当天手里没有股票，所以当天没有股票的利润只能取前一天手里没有股票的利润。<strong>一种是把当天手里的股票给卖了</strong>，既然能卖，说明手里是有股票的，所以这个时候当天没有股票的利润要取前一天手里有股票的利润加上当天股票能卖的价格。这两种情况我们取利润最大的即可，所以可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);</span><br></pre></td></tr></table></figure>



<p><strong>当天交易完之后手里持有股票也有两种情况，一种是当天没有任何交易</strong>，又因为当天手里持有股票，所以当天手里持有的股票其实前一天就已经持有了。<strong>还一种是当天买入了股票</strong>，当天能卖股票，说明前一天手里肯定是没有股票的，我们取这两者的最大值，所以可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);</span><br></pre></td></tr></table></figure>



<p>动态规划的递推公式有了，那么边界条件是什么，就是第一天</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果买入：dp[0][1]=-prices[0];</span><br><span class="line">如果没买：dp[0][0]=0;</span><br></pre></td></tr></table></figure>



<p>有了递推公式和边界条件，代码很容易就写出来了</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 计算最大收益</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span> <span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学计网（一）网络结构与协议</title>
    <url>/2020/08/13/2020813-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6%E8%AE%A1%E7%BD%91%EF%BC%88%E4%B8%80%EF%BC%89%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="OSI与TCP-IP各层结构"><a href="#OSI与TCP-IP各层结构" class="headerlink" title="OSI与TCP/IP各层结构"></a>OSI与TCP/IP各层结构</h1><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2@latest/image/20210325104841.png" alt="avatar"></p>
<font size = 3>

<ol>
<li><strong>应用层</strong>：通过应用进程间的交互来完成特定的网络应用。包括DNS，HTTP，DNS等协议。</li>
<li><strong>运输层</strong>：向两台主机进程之间的通信提供通⽤的数据传输服务（包括TCP和UDP协议） 。</li>
<li><strong>网络层</strong>：计算机⽹络中进⾏通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信⼦⽹。⽹络层的任务就是选择合适的⽹间路由和交换结点， 确保数据及时传送 。（网络层使用IP协议）</li>
<li><strong>数据链路层</strong>：两台主机之间的数据传输，总是在⼀段⼀段的链路上传送的，这就需要使⽤专⻔的链路层的协议。     在两个相邻节点之间传送数据时， 数据链路层将⽹络层交下来的 <strong>IP</strong> 数据报组装成帧 。</li>
<li><strong>物理层</strong>：实现相邻计算机节点之间⽐特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异     。</li>
</ol>
<h1 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2@latest/image/20210325105635.png" alt="avatar"></p>
<ol>
<li><p>三次握手过程：客户端(syn)→服务端(syn/ACK)-&gt;客户端(ACK)-&gt;服务端</p>
</li>
<li><p>为什么要三次握手：</p>
<p>建⽴可靠的通信信道 </p>
<p>双⽅确认⾃⼰与对⽅的发送与接收是正常的 </p>
<p>第一次：s1(无) s2（s1发送正常，s2接收正常）</p>
<p>第二次：s1(s2 收发正常， s1收发正常) s2(同上)</p>
<p>第三次：s1(同上) s2(s1收发正常，s2收发正常)</p>
</li>
<li><p>为什么要传回syn：用来确认信道无误，接收到的就是发送方传来的同一个syn</p>
</li>
<li><p>为什么传回syn还要传回ack：syn用来确认s1到s2的信道无误，而ack用来后续判断s2到s1的信道是否有误</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210325105925.png"></p>
</li>
<li><p>四次挥手过程: s1(FIN) -&gt; s2(ACK,FIN) -&gt; s1(ACK)     -&gt; s2</p>
</li>
<li><p>为什么建立连接是三次握手，而断开需要四次挥手：s2在接收到s1的断开请求后，只是表示s1不会再发送数据了，但可以接收数据，自身可能也有数据需要发送，所以FIN和ACK分开发送。</p>
</li>
</ol>
<h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h1><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210325110037.png"></p>
<p>UDP多用于即时通信：如qq语音视频等</p>
<p>TCP ⼀般⽤于⽂件传输、发送和接收邮件、远程登录等场景 </p>
<h1 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h1><h2 id="保证可靠传输"><a href="#保证可靠传输" class="headerlink" title="保证可靠传输"></a>保证可靠传输</h2><ol>
<li><p>划分应用数据为合适的数据块</p>
</li>
<li><p>给发送的包编号，接收方排序后传送给应用层</p>
</li>
<li><p>校验和： 保持TCP首部和数据的校验和。有差错则丢弃</p>
</li>
<li><p>接收端丢弃重复数据</p>
</li>
<li><p>流量控制： TCP连接双方有固定大小的缓存空间。值允许接受缓存区能够容纳的数据，当来不及处理时，提示发送方降低发送速率，防止包丢失。（TCP利用滑动窗口实现流量控制。）</p>
</li>
<li><p>拥塞控制：网络拥塞时，减少数据的发送</p>
</li>
<li><p>ARQ协议： 没发完一个分组后停止发送，等待对方确认后继续下一组</p>
</li>
<li><p>超时重传：在定时器时长内未能接收到确认信息，重发报文段。</p>
</li>
</ol>
<h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><ol>
<li>停止等待ARQ：</li>
</ol>
<p>每发完⼀个分组就停⽌发送，等待对⽅确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组； </p>
<p>若接收⽅收到重复分组，就丢弃该分组，但同时还要发送确认 </p>
<p>优：简单</p>
<p>缺：信道利用率低，等待时间长</p>
<ol start="2">
<li>连续ARQ协议：</li>
</ol>
<p>发送⽅维持⼀个发送窗⼝，凡位于发送窗⼝内的分组可以连续发送出去，⽽不需要等待对⽅确认。接收⽅⼀般采⽤累计确认，对按序到达的最后⼀个分组发送确认，表明到这个分组为⽌的所有分组都已经正确收到了</p>
<p>优：信道利⽤率⾼，容易实现，即使确认丢失，也不必重传</p>
<p>缺：不能向发送⽅反映出接收⽅已经正确收到的所有分组的信息 （可能需要重传在分组中丢失号数据之后的全部数据）</p>
<h1 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h1><p>流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收 。</p>
<p>接收方ack报文中通过设置窗口字段大小来影响发送方的发送速率</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><ol>
<li><p>拥塞控制是⼀个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低⽹络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。     </p>
</li>
<li><p>TCP 发送⽅要维持⼀个 <strong>拥塞窗⼝**</strong>(cwnd)** 的状态变量。拥塞控制窗⼝的⼤⼩取决于⽹络的拥塞程度，并且动态变化。发送⽅让⾃⼰的发送窗⼝取为拥塞窗⼝和接收⽅的接受窗⼝中较⼩的⼀个     </p>
</li>
<li><p>拥塞控制采用的四种算法：<strong>慢开始、拥塞避免、快重传、快恢复</strong></p>
<p>（1）慢开始：先探测⼀下，即由⼩到⼤逐渐增⼤发送窗⼝，也就是由⼩到⼤逐渐增⼤拥塞窗⼝数值。cwnd初始值为1，每经过⼀个传播轮次， cwnd加倍 </p>
<p>（2）拥塞避免：让拥塞窗⼝cwnd缓慢增⼤，即每经过⼀个往返时间RTT,就把发送方的cwnd加1 </p>
<p>（3）快重传和快恢复（FRR）：没有 FRR，如果数据包丢失了， TCP 将会使⽤定时器来要求传输暂停 .有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。</p>
<p>有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传</p>
<p>和恢复（FRR）能最有效地⼯作。当有多个数据信息包在某⼀段很短的时间内丢失时，它则</p>
<p>不能很有效地⼯作 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>TCP/IP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学Java（一）浅析重写equals方法后必须重写hashCode方法</title>
    <url>/2020/08/14/2020814-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6Java%EF%BC%88%E4%B8%80%EF%BC%89%E6%B5%85%E6%9E%90%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E5%90%8E%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>根据“<strong>类是否覆盖equals()方法</strong>”，将它分为2类。</p>
<p>(01) 若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象。</p>
<p>(02) 我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。</p>
<p>“hashCode() 和 equals() ”是有关系的：</p>
<p>​    1)、如果两个对象相等，那么它们的hashCode()值一定相同。</p>
<p>​       这里的相等是指，通过equals()比较两个对象时返回true。</p>
<p>​    2)、如果两个对象hashCode()相等，它们并不一定相等。</p>
<p>​        因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等</p>
<p><strong>参考代码</strong> (ConflictHashCodeTest1.java)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="number">2</span> <span class="keyword">import</span> java.lang.Comparable;</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">5 * <span class="doctag">@desc</span> 比较equals() 返回true 以及 返回false时， hashCode()的值。</span></span><br><span class="line"><span class="comment">6 *</span></span><br><span class="line"><span class="comment">7 * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment">8 * <span class="doctag">@emai</span> kuiwu-wang@163.com</span></span><br><span class="line"><span class="comment">9 */</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConflictHashCodeTest1</span></span>&#123;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>     <span class="comment">// 新建Person对象，</span></span><br><span class="line"><span class="number">14</span>     Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="number">15</span>     Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="number">16</span>     Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span>     <span class="comment">// 新建HashSet对象 </span></span><br><span class="line"><span class="number">19</span>     HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="number">20</span>     set.add(p1);</span><br><span class="line"><span class="number">21</span>     set.add(p2);</span><br><span class="line"><span class="number">22</span>     set.add(p3);</span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="number">24</span>     <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line"><span class="number">25</span>     System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line"><span class="number">26</span>     <span class="comment">// 打印set</span></span><br><span class="line"><span class="number">27</span>     System.out.printf(<span class="string">&quot;set:%s\n&quot;</span>, set);</span><br><span class="line"><span class="number">28</span>   &#125;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"><span class="number">30</span>   <span class="comment">/**</span></span><br><span class="line"><span class="comment">31   * <span class="doctag">@desc</span> Person类。</span></span><br><span class="line"><span class="comment">32   */</span></span><br><span class="line"><span class="number">33</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="number">34</span>     <span class="keyword">int</span> age;</span><br><span class="line"><span class="number">35</span>     String name;</span><br><span class="line"><span class="number">36</span> </span><br><span class="line"><span class="number">37</span>     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="number">38</span>       <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="number">39</span>       <span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="number">40</span>     &#125;</span><br><span class="line"><span class="number">41</span> </span><br><span class="line"><span class="number">42</span>     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">43</span>       <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+name + <span class="string">&quot;, &quot;</span> +age+<span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="number">44</span>     &#125;</span><br><span class="line"><span class="number">45</span> </span><br><span class="line"><span class="number">46</span>     <span class="comment">/** </span></span><br><span class="line"><span class="comment">47     * <span class="doctag">@desc</span> 覆盖equals方法 </span></span><br><span class="line"><span class="comment">48     */</span> </span><br><span class="line"><span class="number">49</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">50</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123; </span><br><span class="line"><span class="number">51</span>       <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123; </span><br><span class="line"><span class="number">52</span>         <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line"><span class="number">53</span>       &#125; </span><br><span class="line"><span class="number">54</span>        </span><br><span class="line"><span class="number">55</span>       <span class="comment">//如果是同一个对象返回true，反之返回false </span></span><br><span class="line"><span class="number">56</span>       <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123; </span><br><span class="line"><span class="number">57</span>         <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"><span class="number">58</span>       &#125; </span><br><span class="line"><span class="number">59</span>        </span><br><span class="line"><span class="number">60</span>       <span class="comment">//判断是否类型相同 </span></span><br><span class="line"><span class="number">61</span>       <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123; </span><br><span class="line"><span class="number">62</span>         <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line"><span class="number">63</span>       &#125; </span><br><span class="line"><span class="number">64</span>        </span><br><span class="line"><span class="number">65</span>       Person person = (Person)obj; </span><br><span class="line"><span class="number">66</span>       <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age; </span><br><span class="line"><span class="number">67</span>     &#125; </span><br><span class="line"><span class="number">68</span>   &#125;</span><br><span class="line"><span class="number">69</span> &#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/02/clip_image001.gif" alt="复制代码"></a></p>
<p><strong>运行结果</strong>：</p>
<p>p1.equals(p2) : true; p1(1169863946) p2(1690552137)<br> set:[(eee, 100), (eee, 100), (aaa, 200)]</p>
<p><strong>结果分析</strong>：</p>
<p>​    我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p>
<p>​    这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p>
<p>下面，我们同时覆盖equals() 和 hashCode()方法。</p>
<p>参考代码 (ConflictHashCodeTest2.java)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> java.util.*;</span><br><span class="line"> <span class="number">2</span> <span class="keyword">import</span> java.lang.Comparable;</span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 5 * <span class="doctag">@desc</span> 比较equals() 返回true 以及 返回false时， hashCode()的值。</span></span><br><span class="line"><span class="comment"> 6 *</span></span><br><span class="line"><span class="comment"> 7 * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment"> 8 * <span class="doctag">@emai</span> kuiwu-wang@163.com</span></span><br><span class="line"><span class="comment"> 9 */</span></span><br><span class="line"> <span class="number">10</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConflictHashCodeTest2</span></span>&#123;</span><br><span class="line"> <span class="number">11</span> </span><br><span class="line"> <span class="number">12</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="number">13</span>     <span class="comment">// 新建Person对象，</span></span><br><span class="line"> <span class="number">14</span>     Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line"> <span class="number">15</span>     Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line"> <span class="number">16</span>     Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line"> <span class="number">17</span>     Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;EEE&quot;</span>, <span class="number">100</span>);</span><br><span class="line"> <span class="number">18</span> </span><br><span class="line"> <span class="number">19</span>     <span class="comment">// 新建HashSet对象 </span></span><br><span class="line"> <span class="number">20</span>     HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line"> <span class="number">21</span>     set.add(p1);</span><br><span class="line"> <span class="number">22</span>     set.add(p2);</span><br><span class="line"> <span class="number">23</span>     set.add(p3);</span><br><span class="line"> <span class="number">24</span> </span><br><span class="line"> <span class="number">25</span>     <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line"> <span class="number">26</span>     System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line"> <span class="number">27</span>     <span class="comment">// 比较p1 和 p4， 并打印它们的hashCode()</span></span><br><span class="line"> <span class="number">28</span>     System.out.printf(<span class="string">&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;</span>, p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line"> <span class="number">29</span>     <span class="comment">// 打印set</span></span><br><span class="line"> <span class="number">30</span>     System.out.printf(<span class="string">&quot;set:%s\n&quot;</span>, set);</span><br><span class="line"> <span class="number">31</span>   &#125;</span><br><span class="line"> <span class="number">32</span> </span><br><span class="line"> <span class="number">33</span>   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 34   * <span class="doctag">@desc</span> Person类。</span></span><br><span class="line"><span class="comment"> 35   */</span></span><br><span class="line"> <span class="number">36</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="number">37</span>     <span class="keyword">int</span> age;</span><br><span class="line"> <span class="number">38</span>     String name;</span><br><span class="line"> <span class="number">39</span> </span><br><span class="line"> <span class="number">40</span>     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"> <span class="number">41</span>       <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="number">42</span>       <span class="keyword">this</span>.age = age;</span><br><span class="line"> <span class="number">43</span>     &#125;</span><br><span class="line"> <span class="number">44</span> </span><br><span class="line"> <span class="number">45</span>     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">46</span>       <span class="keyword">return</span> name + <span class="string">&quot; - &quot;</span> +age;</span><br><span class="line"> <span class="number">47</span>     &#125;</span><br><span class="line"> <span class="number">48</span> </span><br><span class="line"> <span class="number">49</span>     <span class="comment">/** </span></span><br><span class="line"><span class="comment"> 50     * <span class="doctag">@desc</span>重写hashCode </span></span><br><span class="line"><span class="comment"> 51     */</span> </span><br><span class="line"> <span class="number">52</span>     <span class="meta">@Override</span></span><br><span class="line"> <span class="number">53</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123; </span><br><span class="line"> <span class="number">54</span>       <span class="keyword">int</span> nameHash = name.toUpperCase().hashCode();</span><br><span class="line"> <span class="number">55</span>       <span class="keyword">return</span> nameHash ^ age;</span><br><span class="line"> <span class="number">56</span>     &#125;</span><br><span class="line"> <span class="number">57</span> </span><br><span class="line"> <span class="number">58</span>     <span class="comment">/** </span></span><br><span class="line"><span class="comment"> 59     * <span class="doctag">@desc</span> 覆盖equals方法 </span></span><br><span class="line"><span class="comment"> 60     */</span> </span><br><span class="line"> <span class="number">61</span>     <span class="meta">@Override</span></span><br><span class="line"> <span class="number">62</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123; </span><br><span class="line"> <span class="number">63</span>       <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123; </span><br><span class="line"> <span class="number">64</span>         <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line"> <span class="number">65</span>       &#125; </span><br><span class="line"> <span class="number">66</span>        </span><br><span class="line"> <span class="number">67</span>       <span class="comment">//如果是同一个对象返回true，反之返回false </span></span><br><span class="line"> <span class="number">68</span>       <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123; </span><br><span class="line"> <span class="number">69</span>         <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"> <span class="number">70</span>       &#125; </span><br><span class="line"> <span class="number">71</span>        </span><br><span class="line"> <span class="number">72</span>       <span class="comment">//判断是否类型相同 </span></span><br><span class="line"> <span class="number">73</span>       <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123; </span><br><span class="line"> <span class="number">74</span>         <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line"> <span class="number">75</span>       &#125; </span><br><span class="line"> <span class="number">76</span>        </span><br><span class="line"> <span class="number">77</span>       Person person = (Person)obj; </span><br><span class="line"> <span class="number">78</span>       <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age; </span><br><span class="line"> <span class="number">79</span>     &#125; </span><br><span class="line"> <span class="number">80</span>   &#125;</span><br><span class="line"> <span class="number">81</span> &#125;</span><br></pre></td></tr></table></figure>



<p><strong>运行结果</strong>：</p>
<p>p1.equals(p2) : true; p1(68545) p2(68545)<br> p1.equals(p4) : false; p1(68545) p4(68545)<br> set:[aaa - 200, eee - 100]</p>
<p><strong>结果分析</strong>：</p>
<p>​    这下，equals()生效了，HashSet中没有重复元素。</p>
<p>​    <em>比较p1和p2</em>，我们发现：它们的hashCode()相等，通过equals()比较它们也返回true。所以，p1和p2被视为相等。</p>
<p>​    <em>比较p1和p4</em>，我们发现：虽然它们的hashCode()相等；但是，通过equals()比较它们返回false。所以，p1和p4被视为不相等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashCode</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学Java（二）ConcurrentHashMap为什么是线程安全的</title>
    <url>/2020/08/14/2020814-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6Java%EF%BC%88%E4%BA%8C%EF%BC%89ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84/</url>
    <content><![CDATA[<h1 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h1><font size = 3>

<p>HashMap在扩容的时候会调用resize（）方法，这样的并发操作容易在一个桶上形成环形链表。当获取一个不存在的key时，计算出的index正好时环形链表的下标时就会出现如下的死循环。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416191153.png"></p>
<h1 id="ConcurrentHashMap线程安全"><a href="#ConcurrentHashMap线程安全" class="headerlink" title="ConcurrentHashMap线程安全"></a>ConcurrentHashMap线程安全</h1><p>引入了如下的Segment数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416191307.png"></p>
<p>其中的核心数据，例如value和链表都是由volatile修饰的，保证了数据的可见性。</p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p>jdk1.8抛弃了原有的segment锁，而使用CAS(Compare ans Swap) + synchronized的方式实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210416191607.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学数据结构（一）排序</title>
    <url>/2020/08/14/2020814-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><font size=3>

<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/1156494-ab4cecff133d87b3.png"></p>
<ol start="2">
<li>性能分析</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/1156494-62f859c2ac6f95ff.png"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。<br> 因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：</p>
<ol>
<li>第一层循环：遍历待比较的所有数组元素</li>
<li>第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。<br> 如果：selected &gt; ordered，那么将二者交换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insert_sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔（shell）排序"><a href="#希尔（shell）排序" class="headerlink" title="希尔（shell）排序"></a>希尔（shell）排序</h3><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326160721.png"></p>
<p>算法思想：</p>
<p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。<br> 同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成：</p>
<ol>
<li>第一层循环：将gap依次折半，对序列进行分组，直到gap=1</li>
<li>第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。</li>
</ol>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>基本思想：比较+交换。</p>
<ol>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。<br> 因此我们可以发现，简单选择排序也是通过两层循环实现。<br> 第一层循环：依次遍历序列当中的每一个元素<br> 第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。</li>
</ol>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = numbers.length; <span class="comment">//数组长度</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ; <span class="comment">//中间变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k = i;   <span class="comment">//待确定的位置</span></span><br><span class="line">    <span class="comment">//选择出应该在第i个位置的数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = size -<span class="number">1</span> ; j &gt; i ; j--)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers[j] &lt; numbers[k])</span><br><span class="line">    &#123;</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    temp = numbers[i];</span><br><span class="line">    numbers[i] = numbers[k];</span><br><span class="line">    numbers[k] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序。</strong></p>
<p>首先我们来了解下什么是堆。</p>
<p>堆分为两种：大顶堆和小顶堆，两者的差别主要在于排序方式。</p>
<p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191535.png"></p>
<p>大顶堆的存储结构为：{19,16,15,9,8,1}</p>
<p>小顶堆的存储结构为：{1,8,9,15,16,19}</p>
<p>我举的是两个有序的例子，当然，大顶堆和小顶堆的存储结构未必是有序的，只要父节点大于他的左右孩子节点就是大顶堆了，父节点小于他的孩子左右孩子节点就是小顶堆。</p>
<p><strong>堆排序的基本思想和步骤</strong></p>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p>下面我们举例来说明堆排序的步骤。</p>
<p>给定序列{15,8,1,19,16,9}</p>
<p>首先根据序列构造一个完全二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191614.png"></p>
<p>根据大顶堆的原理，我们构造一个大顶堆，此时我们从最后一个非叶子节点开始，如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191645.png"></p>
<p>大顶堆的存储结构为{19,16,9,8,15,1}</p>
<p>然后我们将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换，步骤如下。</p>
<p>第一步：将堆顶元素19和堆底元素1交换，然后再重建，得到新的大顶堆，存储结构为：{16,15,9,8,1,19}。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191710.png"></p>
<p>第二步：将堆顶元素16和新的无序堆的堆底元素1交换，然后再重建，得到新的大顶堆，存储结构为：{15,8,9,1,16,19}</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191731.png"></p>
<p>第三步：将堆顶元素15和新的无序堆的堆底元素1交换，然后再重建，得到新的大顶堆，存储结构为：{9,8,1,15,16,19}</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191800.png"></p>
<p>第四步：将堆顶元素9和新的无序堆的堆底元素1交换，然后再重建，得到新的大顶堆，存储结构为：{8,1,9,15,16,19}</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191821.png"></p>
<p>第五步，将堆顶元素8和新的无序堆的堆底元素1交换，交换后整个堆为有序，存储结构为:{1,8,9,15,16,19}。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326191842.png"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01.paixu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">19</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            adjustHead(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, j);</span><br><span class="line">            adjustHead(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHead</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; len; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k + <span class="number">1</span> &lt; len &amp;&amp; arr[k + <span class="number">1</span>] &gt; arr[k])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; tmp)&#123;</span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326192212.png"></p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = numbers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size-<span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; size-<span class="number">1</span>-i ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[j] &gt; numbers[j+<span class="number">1</span>])  <span class="comment">//交换两数位置</span></span><br><span class="line">        &#123;</span><br><span class="line">        temp = numbers[j];</span><br><span class="line">        numbers[j] = numbers[j+<span class="number">1</span>];</span><br><span class="line">        numbers[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序的基本思想</strong>：<br>通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，则分别对这两部分继续进行排序，直到整个序列有序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326192807.png"></p>
<p>把整个序列看做一个数组，把第零个位置看做中轴，和最后一个比，如果比它小交换，比它大不做任何处理；交换了以后再和小的那端比，比它小不交换，比他大交换。这样循环往复，一趟排序完成，左边就是比中轴小的，右边就是比中轴大的，然后再用分治法，分别对这两个独立的数组进行排序。</p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numbers 带查找数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low   开始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high  结束位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  中轴所在位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = numbers[low]; <span class="comment">//数组的第一个作为中轴</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; numbers[high] &gt;= temp)</span><br><span class="line">    &#123;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[low] = numbers[high];<span class="comment">//比中轴小的记录移到低端</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; numbers[low] &lt; temp)</span><br><span class="line">    &#123;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[high] = numbers[low] ; <span class="comment">//比中轴大的记录移到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    numbers[low] = temp ; <span class="comment">//中轴记录到尾</span></span><br><span class="line">    <span class="keyword">return</span> low ; <span class="comment">// 返回中轴的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>基本思想：</strong><br>　　归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br>归并排序示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326193340.png"></p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01.paixu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">gb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">98</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = sort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : res) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            sort(nums, low, mid);</span><br><span class="line">            sort(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">            merge(nums, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= mid)&#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= high)&#123;</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; tmp.length; k2++)&#123;</span><br><span class="line">                nums[k2 + low] = tmp[k2];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>假定现在有这样一个整型数组{21,56,88,195,354,1,35,12,6,7}，我们可以看到，最大的数，354，是三位数，也就是说，这个排序最大涉及的数就是一个三位数，那么我们该怎么对这个数组运用基数排序呢？</p>
<p>首先，看这些数的个位，把他们按照个位从小到大排序（注意是按照个位），具体怎么排咱们一会儿看代码，先说原理， 也就是说，原来的数组按照个位排序就变成了{21,1,12,354,195,35,56,6,7,88}</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326203829.png"></p>
<p>从前往后，21，放到1号桶中（我们姑且先把他叫做桶），56放到6号桶中，88放到8号桶……放完之后，再把他们按顺序拿出来，就变成了{21,1,12,354,195,35,56,6,7,88}，很好理解，对吧，之后再按照这样的方法，把十位，百位，都排一遍，当你排完百位的时候，你就发现，数组变得有序了</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326203924.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326203944.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//调用基数排序函数</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义整型数组</span></span><br><span class="line">     <span class="keyword">int</span>[] arr = &#123;<span class="number">21</span>,<span class="number">56</span>,<span class="number">88</span>,<span class="number">195</span>,<span class="number">354</span>,<span class="number">1</span>,<span class="number">35</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">	lsd_RadixSort(arr,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出排序后的数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(arr[i]+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr是要排序的数组，max是数组中最大的数有几位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsd_RadixSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//count数组用来计数</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="comment">//bucket用来当桶（在下面你就理解了什么是桶了），放数据，取数据</span></span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k表示第几位，1代表个位，2代表十位，3代表百位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=max;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把count置空，防止上次循环的数据影响</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别统计第k位是0,1,2,3,4,5,6,7,8,9的数量</span></span><br><span class="line">        <span class="comment">//以下便称为桶</span></span><br><span class="line">        <span class="comment">//即此循环用来统计每个桶中的数据的数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[getFigure(arr[i],k)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用count[i]来确定放置数据的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] = count[i] + count[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行完此循环之后的count[i]就是第i个桶右边界的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用循环把数据装入各个桶中，注意是从后往前装</span></span><br><span class="line">        <span class="comment">//这里是重点，一定要仔细理解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = getFigure(arr[i],k);</span><br><span class="line">            bucket[count[j]-<span class="number">1</span>] = arr[i];</span><br><span class="line">            count[j]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将桶中的数据取出来，赋值给arr</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = bucket[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此函数返回整型数i的第k位是什么</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFigure</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> (i/a[k-<span class="number">1</span>])%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学数据结构（二）红黑树</title>
    <url>/2020/08/14/2020814-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><font size = 3>

<p>红黑树是一种<strong>特殊的二叉查找树</strong>，能够通过操作实现<strong>自平衡</strong>。</p>
<h1 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h1><p>（1）根节点和叶子节点都为黑色</p>
<p>（2）红色节点的子节点都为黑色</p>
<p>（3）任意一个节点到每一个叶子节点的路径所包含的黑色节点树相同。</p>
<p>红黑树的自平衡通过三种操作实现：<strong>左旋</strong>、<strong>右旋</strong>和<strong>变色</strong></p>
<p><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210412103419.png"></p>
<p><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210412103440.png"></p>
<p><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</p>
<h1 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h1><ol>
<li><p>从根结点开始查找，把根结点设置为当前结点；</p>
</li>
<li><p>若当前结点为空，返回null；</p>
</li>
<li><p>若当前结点不为空，用当前结点的key跟查找key作比较；</p>
</li>
<li><p>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</p>
</li>
<li><p>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</p>
</li>
<li><p>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210412103534.png"></p>
<h1 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h1><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p>
<ol>
<li>从根结点开始查找；</li>
<li>若根结点为空，那么插入结点作为根结点，结束。</li>
<li>若根结点不为空，那么把根结点作为当前结点；</li>
<li>若当前结点为null，返回当前结点的父结点，结束。</li>
<li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li>
<li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li>
</ol>
<p>插入时包含以下情景</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210412103708.png"></p>
<h1 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h1><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p>
<p>二叉树删除结点找替代结点有3种情情景：</p>
<ul>
<li>情景1：若删除结点无子结点，直接删除</li>
<li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li>
<li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
        <tag>二叉查找树</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学计网（二）HTTP协议相关</title>
    <url>/2020/08/14/2020814-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6%E8%AE%A1%E7%BD%91%EF%BC%88%E4%BA%8C%EF%BC%89HTTP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="浏览器输入url-gt-gt-显示主页的过程"><a href="#浏览器输入url-gt-gt-显示主页的过程" class="headerlink" title="浏览器输入url-&gt;&gt;显示主页的过程"></a>浏览器输入url-&gt;&gt;显示主页的过程</h1><h1 id="浏览器输入url-gt-gt-显示主页的过程-1"><a href="#浏览器输入url-gt-gt-显示主页的过程-1" class="headerlink" title="浏览器输入url-&gt;&gt;显示主页的过程"></a>浏览器输入url-&gt;&gt;显示主页的过程</h1><h2 id="大致过程："><a href="#大致过程：" class="headerlink" title="大致过程："></a>大致过程：</h2><ol>
<li>浏览器通过DNS解析查找域名对应的IP地址（DNS解析）</li>
<li>浏览器向web服务器发送一个HTTP请求（TCP连接 → 发送HTTP请求）</li>
<li>服务器处理请求</li>
<li>服务器发回HTML响应（服务器处理请求并返回HTTP报文）</li>
<li>浏览器显示HTML（浏览器解析渲染界面 → 连接结束）状态码</li>
</ol>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326151225.png"></p>
<h2 id="一图流解释各协议的作用（HTTP、TCP、IP）"><a href="#一图流解释各协议的作用（HTTP、TCP、IP）" class="headerlink" title="一图流解释各协议的作用（HTTP、TCP、IP）"></a>一图流解释各协议的作用（HTTP、TCP、IP）</h2><p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210326151429.png"></p>
<h1 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h1><ol>
<li>Cookie 主要用于保存用户信息，session     的主要作⽤就是通过服务端记录⽤户的状态 。</li>
<li>Cookie     数据保存在客户端(浏览器端)， Session 数据保存在服务器端 </li>
<li>相对来说 Session 安全性更⾼</li>
</ol>
<h1 id="HTTP1-0和1-1的区别"><a href="#HTTP1-0和1-1的区别" class="headerlink" title="HTTP1.0和1.1的区别"></a>HTTP1.0和1.1的区别</h1><ol>
<li><p> 长连接：1.0默认短连接，HTTP协议是基于TCP协议的，每一次建立断开连接都需要三次握手，四次挥手。1.1默认长连接（Connection：keep alive）。持续方式包括非流水线式和流水线式。</p>
</li>
<li><p>错误状态响应码：1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的</p>
<p> 资源与资源的当前状态发⽣冲突； 410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p>缓存处理：1.0中主要使⽤header⾥的If-Modified-Since,Expires来做为缓存判断的标</p>
<p>准 。1.1则引⼊了更多的缓存控制策略例如Entity tag， If-Unmodified-Since, If-Match,</p>
<p>If-None-Match等更多可供选择的缓存头来控制缓存策略 </p>
</li>
<li><p>带宽优化及网络连接的使用：1.0中，存在⼀些浪费带宽的现象，例如客户端只是需要某个对象的⼀部分，⽽服务器却将整个对象送过来了，并且不⽀持断点续传功能， HTTP1.1则在请求头引⼊了range头域，它允许只请求资源的某个部分，即返回码是206（PartialContent），这样就⽅便了开发者⾃由的选择以便于充分利⽤带宽和连接 </p>
</li>
</ol>
<h1 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h1><p>URI是统一资源标志符，可以唯一标识一个资源</p>
<p>URL是统一资源定位符，除了可以唯一标识一个资源，还指明了如何local到这个资源。</p>
<h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><ol>
<li><p>端口：HTTP端口默认为80；HTTPS为443</p>
</li>
<li><p>安全性和资源消耗：HTTP运行在TCP上，传输内容均为明文，客户端与服务器无法验证对方身份。HTTPS运行在SSL/TLS上，而SSL/TLS运行在TCP上，所有传输内容都采用对称加密，且对称加密的密钥采用了服务器的非对称加密。所以：HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源 。</p>
</li>
<li><p>补充（对称加密与非对称加密）：</p>
<p>对称加密：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密算法有DES、 AES等；</p>
<p>⾮对称加密：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥），加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的⾮对称加密算法有RSA、 DSA等。 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>DNS</tag>
        <tag>会话</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学MySQL（一）索引</title>
    <url>/2020/08/15/2020815-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6MySQL%EF%BC%88%E4%B8%80%EF%BC%89%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>数据库索引的原理：数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 BTree 及其变种 B+Tree。</p>
<p>一般情况下,在没有建立索引的时候, mysql 需要扫描全表及扫描 10W 条数据找这条数据,如果我在 nickname 上建立索引,那么mysql只需要扫描一行数据及为我们找到这条 nickname=’css’ 的数据,是不是感觉性能提升了好多咧….</p>
<p>mysql 的索引分为 单例索引（主键索引、唯一索引、普通索引）和 组合索引。</p>
<ul>
<li>单例索引：一个索引只包含一个列，一个表可以有多个单例索引。</li>
<li>组合索引：一个组合索引包含两个或两个以上的列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `award` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;,</span><br><span class="line">  `aty_id` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;活动场景id&#x27;,</span><br><span class="line">  `nickname` varchar(12) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户昵称&#x27;,</span><br><span class="line">  `is_awarded` tinyint(1) NOT NULL DEFAULT 0 COMMENT &#x27;用户是否领奖&#x27;,</span><br><span class="line">  `award_time` int(11) NOT NULL DEFAULT 0 COMMENT &#x27;领奖时间&#x27;,</span><br><span class="line">  `account` varchar(12) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;帐号&#x27;,</span><br><span class="line">  `password` char(32) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">  `message` varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;获奖信息&#x27;,</span><br><span class="line">  `created_time` int(11) NOT NULL DEFAULT 0 COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `updated_time` int(11) NOT NULL DEFAULT 0 COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line"> ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#x27;获奖信息表&#x27;;</span><br><span class="line"> </span><br><span class="line"> INSERT INTO `award` (`nickname`, `account`, `message`, `created_time`)</span><br><span class="line"> VALUES (&#x27;rSUQFzpkDz3R&#x27;, &#x27;DYxJoqZq2rd7&#x27;, &#x27;aaabbbccccxuxuxuxuuxux&#x27;, 1449567822);</span><br></pre></td></tr></table></figure>

<h1 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h1><h2 id="单例索引"><a href="#单例索引" class="headerlink" title="单例索引"></a>单例索引</h2><ol>
<li>普通索引</li>
</ol>
<p>是最基本的索引。</p>
<p>其 sql 格式是 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX IndexName ON `TableName`(`字段名`(length));</span><br></pre></td></tr></table></figure>

<p> # 或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length));</span><br></pre></td></tr></table></figure>

<p>第一种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX account_Index ON `award`(`account`);</span><br></pre></td></tr></table></figure>

<p>第二种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE award ADD INDEX account_Index(`account`);</span><br></pre></td></tr></table></figure>

<p>如果是 CHAR , VARCHAR 类型, length 可以小于字段的实际长度,如果是BLOB和TEXT类型就必须指定长度。</p>
<ol>
<li>唯一索引，与普通索引类似，但是不同的是唯一索引要求所有的列的值是唯一的，这一点和主键索引一样，但是它允许有空值。</li>
</ol>
<p>其 sql 格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));</span><br></pre></td></tr></table></figure>

<p> # 或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TableName ADD UNIQUE (column_list); </span><br></pre></td></tr></table></figure>

<p>第一种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX account_UNIQUE_Index ON `award`(`account`);</span><br></pre></td></tr></table></figure>



<ol>
<li>主键索引，不允许有空值,（在     B+Tree 中的 InnoDB 引擎中，主键索引起到了至关重要的位置）</li>
</ol>
<p>主键索引建立的规则是 int 优于 varchar，一般在建表的时候创建，最好是与表的其他字段不相关的列或者是业务不相关的列。一般会设为 int 而且是 AUTO_INCREMENT 自增类型的。</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>一个表中含有多个单例索引不代表是组合索引，通俗一点讲，组合索引是：包含多个字段但是只有索引名称。</p>
<p>其 sql 格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX nickname_account_createdTime_Index ON `award`(`nickname`, `account`, `created_time`);</span><br></pre></td></tr></table></figure>

<p>如果你建立了组合索引 (nickname_account_createdTime_Index)，那么它实际包含的是 3 个索引 (nickname) (nickname,account)(nickname,account,created_time)</p>
<p>在使用查询的时候遵循 mysql 组合索引的 “最左前缀”，即索引 where 时的条件要按照建立索引的时候字段的排列方式。</p>
<ol>
<li>不按索引最左列开始查询（多列索引）     例如</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index(‘c1’, ‘c2’, ‘c3’) where c2 = &#x27;aaa&#x27; # 不使用索引</span><br><span class="line">where c2 = &#x27;aaa&#x27; and c3=&#x27;sss&#x27; # 不能使用索引</span><br></pre></td></tr></table></figure>



<ol>
<li>查询某个列有范围查询，则其右边的所有列都无法使用查询（多列查询）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Where c1= &#x27;xxx&#x27; and c2 like &#x27;aa%&#x27; and c3=&#x27;sss&#x27;</span><br></pre></td></tr></table></figure>


<p> # 该查询只会使用索引中的前两列,因为like是范围查询</p>
<ol>
<li>不能跳过某个字段来进行查询，这样利用不到索引，比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `award` WHERE nickname &gt; &#x27;rSUQFzpkDz3R&#x27; AND account = &#x27;DYxJoqZq2rd7&#x27; AND created_time = 1449567822; </span><br></pre></td></tr></table></figure>

<p>因为我的索引是 (nickname, account, created_time)，如果第一个字段出现 范围符号 的查找，那么将不会用到索引，如果我是第二个或者第三个字段使用范围符号的查找，那么它会利用索引，利用的索引是 (nickname)，因为上面说了建立组合索引 (nickname, account, created_time)，会出现三个索引。</p>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>文本字段上（text）如果建立的是普通索引，那么只有对文本的字段内容前面的字符进行索引，其字符大小根据索引建立索引时声明的大小来规定。</p>
<p>如果文本中出现多个一样的字符，而且需要查找的话，那么其条件只能是 where column like ‘%xxxx%’， 这样做会让索引失效</p>
<p>这个时候全文索引就有作用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TableName ADD FULLTEXT(column1, column2);</span><br><span class="line"></span><br><span class="line">ALTER TABLE `award` ADD FULLTEXT(`message`);</span><br></pre></td></tr></table></figure>

<p>有了全文索引，就可以用 SELECT 查询命令去检索那些包含着一个或多个给定单词的数据记录了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TableName WHERE MATCH(column1, column2) AGAINST(&#x27;xxx&#x27;, &#x27;sss&#x27;, &#x27;ddd&#x27;);</span><br><span class="line"></span><br><span class="line"> EXPLAIN SELECT * FROM `award` WHERE MATCH(message) AGAINST(&#x27;aaa&#x27;);</span><br></pre></td></tr></table></figure>

<p>上述命令将把 column1 和 column2 字段里有 xxx、sss、和 ddd 的数据记录全部查询出来。</p>
<h1 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h1><ul>
<li>查询索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM TableName;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM award;</span><br></pre></td></tr></table></figure>



<ul>
<li>删除索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX IndexName ON `TableName`;</span><br></pre></td></tr></table></figure>

<h1 id="使用索引的优点"><a href="#使用索引的优点" class="headerlink" title="使用索引的优点"></a>使用索引的优点</h1><p>1）可以通过建立唯一索引或者主键索引，保证数据库表中每一行数据的唯一性</p>
<p>2）建立索引可以大大提高检索的数据，以及减少表的检索行数</p>
<p>3）在表连接的连接条件，可以加速表与表直接的相连</p>
<p>4）在分组和排序字句进行数据检索，可以减少查询时间中 分组 和 排序 所消耗的时间（数据库的记录会重新排序）</p>
<p>5）建立索引，在查询中使用索引，可以提高性能</p>
<h1 id="使用索引的缺点"><a href="#使用索引的缺点" class="headerlink" title="使用索引的缺点"></a>使用索引的缺点</h1><p>1）创建索引和维护索引会消耗时间，随着数据量的增加而增加</p>
<p>2）索引文件会占用物理空间，除了数据表需要占用物理空间之外，每一个索引还会占用一定的物理空间</p>
<p>3）当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。</p>
<h1 id="使用索引需要注意的地方"><a href="#使用索引需要注意的地方" class="headerlink" title="使用索引需要注意的地方"></a>使用索引需要注意的地方</h1><p>在建立索引的时候应该考虑索引该建立在数据库表中的某些列上，哪一些索引需要建立，哪一些索引是多余的，一般来说：</p>
<p>1）在经常需要搜索的列上,可以加快索引的速度</p>
<p>2）主键列上可以确保列的唯一性</p>
<p>3）在表与表的连接条件上加上索引,可以加快连接查询的速度</p>
<p>4）在经常需要排序 (order by) ,分组 (group by) 和的 distinct 列上加索引 可以加快排序查询的时间, (单独order by 用不了索引，索引考虑加where 或加limit)</p>
<p>5）在一些 where 之后的 &lt; &lt;= &gt; &gt;= BETWEEN IN 以及某个情况下的like 建立字段的索引(B-TREE)</p>
<p>6）like语句，前导模糊查询 like “%XXX” 不能使用索引，而非前导模糊查询 like “XXX%” 则可以</p>
<p>7）索引不会包含 NULL 列,如果列中包含 NULL 值都将不会被包含在索引中,复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ‘ ‘ 字符串</p>
<p>8）使用短索引,如果你的一个字段是 Char(32) 或者 int(32) ,在创建索引的时候指定前缀长度 比如前10个字符 (前提是多数值是唯一的..)那么短索引可以提高查询速度,并且可以减少磁盘的空间,也可以减少I/0操作.</p>
<p>9）不要在列上进行运算,这样会使得mysql索引失效,也会进行全表扫描</p>
<p>10）选择越小的数据类型越好,因为通常越小的数据类型通常在磁盘,内存,cpu,缓存中 占用的空间很少,处理起来更快</p>
<h1 id="不创建索引的情况"><a href="#不创建索引的情况" class="headerlink" title="不创建索引的情况"></a>不创建索引的情况</h1><p>1）查询中很少使用到的列不应该创建索引,如果建立了索引然而还会降低mysql的性能和增大了空间需求.</p>
<p>2）很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率</p>
<p>3）定义为 text 和 image 和 bit 数据类型的列不应该增加索引</p>
<p>4）当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系</p>
<h1 id="MySQL的索引优化"><a href="#MySQL的索引优化" class="headerlink" title="MySQL的索引优化"></a>MySQL的索引优化</h1><ul>
<li>负向条件不能使用索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order where status!=0 and status!=1</span><br><span class="line"></span><br><span class="line">not in/not exists # 都不是好习惯</span><br></pre></td></tr></table></figure>

<p>可以优化为 in 查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order where status in(2,3)</span><br></pre></td></tr></table></figure>



<ul>
<li>前导模糊查询不能使用索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order where desc like &#x27;%XX&#x27;</span><br></pre></td></tr></table></figure>

<p>而非前导模糊查询则可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order where desc like &#x27;XX%&#x27;</span><br></pre></td></tr></table></figure>



<ul>
<li>数据区分度不大的字段不宜使用索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where sex=1</span><br></pre></td></tr></table></figure>

<p>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。</p>
<p>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。</p>
<ul>
<li>在属性上进行计算不能命中索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order_ where YEAR(date) &lt;= &#x27;2017&#x27;</span><br></pre></td></tr></table></figure>

<p>即使 date 上建立了索引，也会全表扫描，可优化为值计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order_ where date &lt;= CURDATE()</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order_ where date &lt; = &#x27;2017-01-01&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>并非周知的 SQL 实践</strong></p>
<ul>
<li>如果业务大部分是单条查询，使用     Hash 索引性能更好，例如用户中心</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from `user` where uid = ?</span><br><span class="line"> select from user where login_name=?</span><br></pre></td></tr></table></figure>

<p>原因：B-Tree索引的时间复杂度是 O(log(n))；Hash 索引的时间复杂度是 O(1)</p>
<ul>
<li>允许 null的列，查询有潜在大坑</li>
</ul>
<p>单列索引不存 null 值，复合索引不存全为 null 的值，如果列允许为 null，可能会得到“不符合预期”的结果集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where name != &#x27;shenjian&#x27;</span><br></pre></td></tr></table></figure>

<p>如果 name 允许为 null，索引不存储null值，结果集中不会包含这些记录。所以，请使用 not null 约束以及默认值。</p>
<ul>
<li>复合索引最左前缀，并不是指 SQL     语句的 where顺序要和符合索引一致。</li>
</ul>
<p>用户中心建立了 (login_name, password) 的符合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where login_name=? and passwd=?</span><br><span class="line"> select from user where passwd=? and login_name=?</span><br></pre></td></tr></table></figure>

<p>都能够命中索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where login_name=?</span><br></pre></td></tr></table></figure>

<p>也能命中索引，满足符合索引最左前缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where passwd=?</span><br></pre></td></tr></table></figure>

<p>不能命中索引，不满足符合索引最左前缀。</p>
<ul>
<li>使用 ENUM 而不是字符串</li>
</ul>
<p>ENUM 保存的是 TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。</p>
<p><strong>小众但有用的 SQL 实践</strong></p>
<ul>
<li>如果明确知道只有一条结果返回，limit     1 能够提高效率</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where login_name=?</span><br></pre></td></tr></table></figure>

<p>可以优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where login_name=? limit 1</span><br></pre></td></tr></table></figure>

<p>原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动</p>
<ul>
<li>把计算放到业务层而不是数据库层，除了节省数据的     CPU，还有意想不到的查询缓存优化效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from order where date &lt; = CURDATE()</span><br></pre></td></tr></table></figure>

<p>这不是一个号的 SQL 实践，应该优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$curDate = date(&#x27;Y-m-d&#x27;);</span><br><span class="line"> $res = mysqlquery(&#x27;select from order where date &lt; = $curDate&#x27;);</span><br></pre></td></tr></table></figure>

<p>原因：释放了数据库的 CPU，多次调用，传入的SQL相同，才可以利用查询缓存</p>
<ul>
<li>强制类型转换会全表扫描</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from user where phone=13800001234</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学操作系统（一）进线程与内存管理</title>
    <url>/2020/08/15/2020815-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E8%BF%9B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><ol>
<li><p>操作系统是管理计算机软硬件资源的程序，是计算机的基石。</p>
</li>
<li><p>本质上是一个应用程序。</p>
</li>
<li><p>操作系统的存在屏蔽了硬件设备的复杂性，由操作系统统一管理和分配。</p>
</li>
<li><p>内核是操作系统的核心部分。负责系统的内存管理，硬件设备管理，文件系统管理和应用程序管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210327105916.png"></p>
</li>
</ol>
<h1 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h1><p>用户态：该状态运行的进程可以直接读取用户程序的数据。</p>
<p>系统态：该状态运行的进程或程序可以访问计算机任意资源。</p>
<p>程序运行在用户态时想要调用操作系统提供的系统态子功能时需要进行系统调用。</p>
<p>系统调用按功能大致分为：</p>
<p><strong>设备管理</strong>。完成设备的请求或释放，以及设备启动等功能。</p>
<p><strong>⽂件管理</strong>。完成⽂件的读、写、创建及删除等功能。</p>
<p><strong>进程控制</strong>。完成进程的创建、撤销、阻塞及唤醒等功能。</p>
<p><strong>进程通信</strong>。完成进程之间的消息传递或信号传递等功能。</p>
<p><strong>内存管理</strong>。完成内存的分配、回收以及获取作业占⽤内存区⼤⼩及地址等功能。</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><ol>
<li><p>区别：线程时进程划分成的更小的运行单位。进程之间基本相互独立，而线程之间可能相互影响。线程执行开销小，但不利于资源的管理和保护，而进程则相反。</p>
</li>
<li><p>进程的状态：</p>
<p>创建状态**(new)** ：进程正在被创建，尚未到就绪状态。</p>
<p>就绪状态**(ready)** ：进程已处于准备运⾏状态，即进程获得了除了处理器之外的⼀切所需资</p>
<p>源，⼀旦得到处理器资源(处理器分配的时间⽚)即可运⾏。</p>
<p>运⾏状态**(running)** ：进程正在处理器上上运⾏(单核 CPU 下任意时刻只有⼀个进程处于运</p>
<p>⾏状态)。</p>
<p>阻塞状态**(waiting)** ：⼜称为等待状态，进程正在等待某⼀事件⽽暂停运⾏如等待某资源为</p>
<p>可⽤或等待 IO 操作完成。即使处理器空闲，该进程也不能运⾏。</p>
<p>结束状态**(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运⾏。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210327110050.png"></p>
</li>
<li><p>进程间的通信方式：</p>
<p>（1）管道（匿名管道）：用于有情缘关系的进程。</p>
<p>（2）有名管道： 任意进程，先进先出。</p>
<p>（3） 信号： 通知接收进程某个事件已经发生。</p>
<p>（4） 消息队列： 存放在内核中。克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限的缺陷。</p>
<p>（5） 信号量：计数器，多进程对共享数据的访问。进程间同步。</p>
<p>（6） 共享内存： 多个进程访问同一快内存空间</p>
<p>（7）套接字：用于客户端和服务器之间通过网络进行通信。</p>
</li>
<li><p>线程间的同步方式：</p>
<p>（1） 互斥量</p>
<p>（2） 信号量：允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最⼤线程数量</p>
<p>（3） 事件：通过通知操作的⽅式来保持多线程同步，还可以⽅便的实现多线程优先级的⽐较操做</p>
</li>
<li><p>进程的调度算法：</p>
<p>（1） 先到先服务（FCFS）</p>
<p>（2） 短作业优先（SJF）</p>
<p>（3） 时间片轮转</p>
<p>（4） 多级反馈队列调度算法：多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。，因⽽它是⽬前被公认的⼀种较好的进程调度算法</p>
<p>（5）优先级调度：同一优先级采用FCFS调度</p>
</li>
</ol>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="常见的内存管理机制"><a href="#常见的内存管理机制" class="headerlink" title="常见的内存管理机制"></a>常见的内存管理机制</h2><ol>
<li><p>连续分配管理方式：为⼀个⽤户程序分配⼀个连续的内存空间 </p>
<p>（1）块式管理：在每个块中未被利⽤的空间，我们称之为碎⽚ </p>
</li>
<li><p>非连续分配管理方式：允许⼀个程序使⽤的内存分布在离散或者说不相邻的内存中 </p>
<p>（1）页式管理：主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式 ，通过⻚表对应逻辑地址和物理地址</p>
<p>（2）段式管理：段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。段式管理通过段表对应逻辑地址和物理地址 。</p>
<p>（3）段页式管理：结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的 </p>
</li>
</ol>
<h2 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h2><p>在分⻚内存管理中，很重要的两点是：</p>
<ol>
<li><p>虚拟地址到物理地址的转换要快。</p>
</li>
<li><p>解决虚拟地址空间⼤，⻚表也会很⼤的问题。</p>
</li>
</ol>
<p>快表：把快表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中的内容是⻚表的⼀部分或者全部内容。 采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度 。</p>
<p>快表的地址转换流程：</p>
<ol>
<li><p>根据虚拟地址中的⻚号查快表；</p>
</li>
<li><p>如果该⻚在快表中，直接从快表中读取相应的物理地址；</p>
</li>
<li><p>如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该</p>
</li>
</ol>
<p>映射表项添加到快表中；</p>
<ol start="4">
<li>当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。</li>
</ol>
<p>多级页表：引⼊多级⻚表的主要⽬的是为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景。 </p>
<h2 id="分页机制和分段机制的异同"><a href="#分页机制和分段机制的异同" class="headerlink" title="分页机制和分段机制的异同"></a>分页机制和分段机制的异同</h2><ol>
<li><p>共同点：</p>
<p>（1）分⻚机制和分段机制都是为了提⾼内存利⽤率，减少内存碎⽚。</p>
<p>（2）⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，每个⻚和段中的内存是连续的 </p>
</li>
<li><p>不同点：</p>
<p>（1）⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏程序。</p>
<p>（2）分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满⾜⽤户的需要。 </p>
</li>
</ol>
<h2 id="逻辑（虚拟地址）和物理地址"><a href="#逻辑（虚拟地址）和物理地址" class="headerlink" title="逻辑（虚拟地址）和物理地址"></a>逻辑（虚拟地址）和物理地址</h2><p>   指针⾥⾯存储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h2 id="CPU寻址，为什么需要虚拟地址空间"><a href="#CPU寻址，为什么需要虚拟地址空间" class="headerlink" title="CPU寻址，为什么需要虚拟地址空间"></a>CPU寻址，为什么需要虚拟地址空间</h2><p>使⽤虚拟寻址， <strong>CPU</strong>需要将<strong>虚拟地址翻译成物理地址<strong><strong>（由</strong></strong>CPU****中内存管理单元硬件完成）</strong>，这样才能访问到真实的物理内存。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210327110407.png"></p>
<p>为什么要有虚拟地址空间：没有时，程序直接访问操作物理内存。可能造成操作系统崩溃，运行多个程序特别困难。</p>
<p><strong>通过虚拟地址访问内存有以下优势：</strong></p>
<p>程序可以使⽤⼀系列<strong>相邻的虚拟地址</strong>来访问<strong>物理内存中不相邻</strong>的⼤内存缓冲区。</p>
<p>程序可以使⽤⼀系列虚拟地址来访问<strong>⼤于可⽤物理内存的内存缓冲区</strong>。当物理内存的供应量变⼩时，内存管理器会将物理内存⻚（通常⼤⼩为 4 KB）保存到磁盘⽂件。数据或代码⻚会根据需要在物理内存与磁盘之间移动。</p>
<p>不同进程使⽤的<strong>虚拟地址彼此隔离</strong>。⼀个进程中的代码⽆法更改正在由另⼀进程或操作系统使⽤的物理内存。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h3><p>虚拟内存 可以让程序可以拥有超过系统物理内存⼤⼩的可⽤内存空间。另外， 虚拟内存为每个进程提供了⼀个⼀致的、私有的地址空间，它让每个进程产⽣了⼀种⾃⼰在独享主存的错觉（每个进程拥有⼀⽚连续完整的内存空间） 。 </p>
<p>虚拟内存的重要意义是它定义了⼀个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。 </p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>虚拟内存技术的基础，正是因为程序运⾏具有局部性原理，才可以只装⼊部分程序到内存就开始运⾏。 </p>
<ol>
<li>时间局部性 ：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着⼤量的循环操作。</li>
<li>空间局部性 ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执⾏的，数据也⼀般是以向量、数组、表等形式簇聚存储的。     </li>
</ol>
<p>时间局部性是通过将近来使⽤的指令和数据保存到⾼速缓存存储器中，并使⽤⾼速缓存的层次结构实现。空间局部性通常是使⽤较⼤的⾼速缓存，并将预取机制集成到⾼速缓存控制逻辑中实现。虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利⽤局部性原理实现髙速缓存。 </p>
<h3 id="虚拟内存的技术实现"><a href="#虚拟内存的技术实现" class="headerlink" title="虚拟内存的技术实现"></a>虚拟内存的技术实现</h3><p>建⽴在离散分配的内存管理⽅式的基础上 </p>
<ol>
<li><p>请求分⻚存储管理 ：建⽴在分⻚管理之上，为了⽀持虚拟存储器功能⽽增加了请求调⻚功能和⻚⾯置换功能。 </p>
</li>
<li><p>请求分段存储管理 ：建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。 </p>
</li>
<li><p>请求段⻚式存储管理     </p>
</li>
</ol>
<p>补充：</p>
<p>缺⻚中断：如果需执⾏的指令或访问的数据尚未在内存 称为缺⻚或缺段），则由处理器通</p>
<p>知操作系统将相应的⻚⾯或段调⼊到内存，然后继续执⾏程序 。</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>⻚⾯置换算法的作⽤**?**常⻅的⻚⾯置换算法有哪些 ？</p>
<p>当发⽣缺⻚中断时，如果当前内存中并没有空闲的⻚⾯，操作系统就必须在内存选择⼀个⻚⾯将其移出内存，以便为即将调⼊的⻚⾯让出空间。 </p>
<ol>
<li>OPT（最佳页面置换算法）：换出后续永不会再用到的页面，只在理论上存在。</li>
<li>FIFO</li>
<li>LRU（最近最久未使用页面置换算法）</li>
<li>LFU（最少使用页面置换算法）</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>虚拟内存</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学设计模式（一）单例模式的常用实现方法</title>
    <url>/2020/08/15/2020815-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="单例模式是什么？"><a href="#单例模式是什么？" class="headerlink" title="单例模式是什么？"></a>单例模式是什么？</h1><font size = 3>

<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时<strong>确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h1 id="单例模式实现方式"><a href="#单例模式实现方式" class="headerlink" title="单例模式实现方式"></a>单例模式实现方式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>类加载的时候就创建了实例<br>优点：类加载的时候创建一次实例，避免了多线程同步问题</p>
<p>缺点：即使单例没被用到也会创建，浪费内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>优点：需要时才去创建<br>缺点：没有考虑线程安全问题，多个线程并发调用getInstance，可能会创建多个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>缺点：性能问题，添加了synchronized的函数比一般方法慢得多，若多次调用getInstance，则累积的性能损耗特别大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Synchronized Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p>大部分情况下，同步代码块都不会执行到，提高了程序的性能。</p>
<p>有一种情况，两个线程ThreadA，ThreadB，如果threadA执行到了第一个if条件判断，instance = null；ThreadB也执行到了if条件判断instance = null，所以A和B会依次执行同步代码块里的代码。为了避免创建两个实例，因此又在同步代码块里添加了if条件进行二重检验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐患：</p>
<p>1、此处涉及Java的指令重排优化。指令重排优化是指在不改变原语义的情况下，通过调整指令的执行顺序让程序运行地更快。</p>
<p>2、JVM中没有规定编译器优化的相关内容，也即JVM可以自由地进行指令重排序的优化。</p>
<p>3、此问题的关键在于由于指令重排序优化的存在，导致初始化Singleton和将对象地址赋给instance字段的顺序是不确定的。</p>
<p>4、在某个线程创建单例对象时，在构造函数被调用前，就为该对象分配了内存空间并将对象的字段设置为默认值。此时就可以将分配的内存地址赋值给instance字段了，然而该对象可能还没初始化。若紧接着另一个线程来调用getInstance，获取到的就是状态不正确的对象，程序出错。</p>
<p>JDK5的修正：以上是双重校验锁失效的原因，不过在JDK1.5之后的版本添加了volatile关键字。</p>
<p>1、volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的，从而避免了上述问题。</p>
<p>2、Java中的volatile变量是什么？</p>
<p>（1）关键字的作用有两个：</p>
<p>​      ①多线程主要围绕可见性和原子性两个特性展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到的volatile变量，一定是最新的数据。</p>
<p>​     ②代码底层执行的顺序是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互。实际中，为了获取更好的性能，JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会禁止语义重排序，也一定程度上降低了代码执行效率。实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性。</p>
<p>   （2）volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其他线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学操作系统（二）IO多路复用技术</title>
    <url>/2020/08/15/2020815-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><font size=3>

<ol>
<li><p>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：</p>
<p>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。</p>
<p>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</p>
<p>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p>
<p>（4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</p>
<p><strong>同步和异步</strong>的概念描述的是用户线程与内核的交互方式：同步是指<strong>用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行</strong>；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p>
<p><strong>阻塞和非阻塞</strong>的概念描述的是用户线程调用内核IO操作的方式：<strong>阻塞是指IO操作需要彻底完成后才返回到用户空间</strong>；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p>
</li>
</ol>
<h1 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h1><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210404095213.png"></p>
<h1 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h1><p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210404095300.png"></p>
<p>整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要<strong>不断地轮询、重复请求</strong>，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同<strong>一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210404095402.png"></p>
<p>通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而<strong>Reactor线程负责调用内核的select函数检查socket状态</strong>。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</p>
<h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210404095443.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>请教我学MySQL（一）乐观锁vs悲观锁</title>
    <url>/2020/08/16/2020816-%E8%AF%B7%E6%95%99%E6%88%91%E5%AD%A6MySQL%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81vs%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><font size = 3>

<p>当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210330102059.png"></p>
<p>之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是<strong>假设最坏的情况</strong>，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。悲观锁的实现：</p>
<ol>
<li>传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>Java 里面的同步 synchronized]关键字的实现。</li>
</ol>
<p><strong>悲观锁分为共享（读）锁和排他（写）锁</strong></p>
<p><strong>共享锁</strong>【shared locks】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p>
<p><strong>排他锁</strong>【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在<strong>数据进行提交更新的时候，才会正式对数据的冲突与否进行检测</strong>，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ls19970727/CDN2/image/20210330102206.png"></p>
<p>乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现：</p>
<ol>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li>
<li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</li>
</ol>
<p> 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC（一）</title>
    <url>/2021/05/13/2021513-SpringMVC%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ssm: mybatis + spring + springMVC</p>
<p>ssm = JavaWeb做项目</p>
<p><strong>Spring：IOC和AOP【重要】</strong></p>
<p><strong>SpringMVC的执行流程【重要】</strong></p>
<h1 id="回顾MVC模式"><a href="#回顾MVC模式" class="headerlink" title="回顾MVC模式"></a>回顾MVC模式</h1><p>模型（dao，service） 视图（jsp） 控制器（servlet）</p>
<p><strong>jsp：本质就是一个servlet</strong></p>
<h1 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h1><p>Spring MVC是Spring Framework的一部分，是基于java实现MVC的轻量级Web框架。</p>
<p>特点：</p>
<p>1.轻量级，简单易学</p>
<p>2.高效，基于请求响应的MVC框架</p>
<p>3.与Spring兼容性好，无缝结合</p>
<p><strong>4.约定大于配置</strong></p>
<p>5.功能强大：RESTful、数据验证、格式化、本地化、主题等</p>
<p>6.简洁灵活</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>网易云歌单导入AppleMusic</title>
    <url>/2020/06/23/%E7%BD%91%E6%98%93%E4%BA%91%E6%AD%8C%E5%8D%95%E5%AF%BC%E5%85%A5AppleMusic/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Apple Music作为ios内的一款音乐APP，学生认证后五元一月的价格实属良心，当然比起国内大量的音乐软件，收录的华人音乐内容偏少，优质的段子手评论也很少。但是优势却也很明显，普通音质的音乐比起其他软件的无损音乐要更加高（简直是无损中的无损啊）。所以如果你追求极致的音质体验，又偏爱欧美音乐时，Apple Music确实是性价比最高的选择了。</p>
<p>但是，在小编从网易云音乐转用Apple Music时却发现这是一件极其痛苦的事情，一方面沉醉于Apple Music使用的简洁风格的流畅用户体验以及夸张的音质。一方面又难以割舍网易云音乐中一颗一颗小红星攒出来只属于我自己的歌单（泪奔）。难道我要从网易云的歌单中一首接一首的去Apple Music中搜索id然后添加到音乐库中去吗，看着我那500+音乐的歌单陷入了沉思….</p>
<p>事实上，我们可以利用ios上默认安装的一款app，快捷指令（原捷径）一键导入歌单。具体步骤如下：</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-下载“网易云→Apple-Music”快捷指令"><a href="#1-下载“网易云→Apple-Music”快捷指令" class="headerlink" title="1. 下载“网易云→Apple Music”快捷指令"></a>1. 下载“网易云→Apple Music”快捷指令</h2><p>关注公众号：“程序员评测室”后台回复“导入歌单”可以获取下载链接（由于要调用到快捷指令，请在safari中打开该链接）</p>




<p>点击上图下方获取捷径。</p>




<p>出现上图所示内容，下拉到底部。</p>




<p>点击添加不受信任的快捷指令（注意：该快捷指令并无恶意内容，由于是非苹果官方捷径库的第三方捷径，所以会有该提示，请放心使用），到这里我们就成功将该捷径添加进了捷径中心。</p>
<h2 id="2-复制网易云歌单中的歌单链接"><a href="#2-复制网易云歌单中的歌单链接" class="headerlink" title="2. 复制网易云歌单中的歌单链接"></a>2. 复制网易云歌单中的歌单链接</h2><p> 具体操作：首先点开你想复制的歌单，然后点击分享，最后点击复制链接。</p>




<h2 id="3-利用捷径开始复制这个歌单吧！"><a href="#3-利用捷径开始复制这个歌单吧！" class="headerlink" title="3. 利用捷径开始复制这个歌单吧！"></a>3. 利用捷径开始复制这个歌单吧！</h2><p>退出网易云，进入捷径中心，点击我们在步骤一中成功添加的捷径并授予系统提示的相关权限。接下来在一段时间的等待过后就可以在Apple Music中看到我们成功复制的歌单啦！（注意，等待时间的长短取决于你歌单中音乐数量的多少，我亲测复制300+音乐用时半小时），在等待过程中不要把捷径中心挂在后台，会出现提前结束捷径的情况。</p>




<p>下面就是我自己成功复制的歌单啦！</p>




<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>好啦，到这里就结束啦，快去将你心爱的网易云歌单导入Apple Music吧！</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>手机</tag>
        <tag>ios</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>利用猫抓下载网页上的视频</title>
    <url>/2020/06/22/%E5%88%A9%E7%94%A8%E7%8C%AB%E6%8A%93%E4%B8%8B%E8%BD%BD%E7%BD%91%E9%A1%B5%E4%B8%8A%E7%9A%84%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        直奔主题上教程啦。首先我们需要准备以下工具:Chrome浏览器+猫抓拓展包（关注程序员评测室公众号回复猫抓拓展包）。接下来就可以开始你的视频抓取之路啦！</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-打开chrome的开发者模式"><a href="#1-打开chrome的开发者模式" class="headerlink" title="1 打开chrome的开发者模式"></a>1 打开chrome的开发者模式</h2><p>打开Chrome 浏览器，按图示顺序依次点击更多→更多工具→拓展程序</p>








<p>​        打开后就是如下页面，查看右上角开发者模式是否处于打开状态（关闭模式下点击一下开启）。</p>




<h2 id="2-安装拓展包"><a href="#2-安装拓展包" class="headerlink" title="2 安装拓展包"></a>2 安装拓展包</h2><p>​        将后缀名为crx的拓展包拖入图示区域。</p>




<p>​        拖动到指定区域后出现以下内容，点击添加拓展程序。</p>




<p>好啦！恭喜你已经完成了拓展程序的安装，我们可以看到浏览器右上方已经出现了猫抓的图标。</p>




<h2 id="3-开始下载视频"><a href="#3-开始下载视频" class="headerlink" title="3 开始下载视频"></a>3 开始下载视频</h2><p>​        打开某个包含视频内容的网站，我们可以看到猫抓小图标上出现了一些数字，这个数字表示当前页面存在可下载的视频数量。点击猫抓图标就可以下载对应的内容啦！</p>




<p>​        下载完成后记得将下载的文件后缀名修改为.mp4</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>​        使用该方法有点复杂，不过你学会了拓展程序的安装就如同打开了一扇新世界的大门啊！通过安装实用的浏览器拓展程序将会让你的日常使用更加得心应手。</p>
<p>推荐下某乎大神给的<a href="https://www.zhihu.com/question/19594682/answer/693396771?hb_wx_block=1">拓展程序</a>。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>电脑</tag>
        <tag>网页</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客题解-NC68跳台阶</title>
    <url>/2021/05/18/%E7%89%9B%E5%AE%A2%E9%A2%98%E8%A7%A3-NC68%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>与斐波那契数列一样，只是初始状态改为</p>
<p>f（0）= f（1）= 1；</p>
<p>状态转移方程仍然为：</p>
<p>f（n） = f（n - 1） + f (n - 2);</p>
<p>题目分析，假设f[i]表示在第i个台阶上可能的方法数。逆向思维。如果我从第n个台阶进行下台阶，下一步有2中可能，一种走到第n-1个台阶，一种是走到第n-2个台阶。所以f[n] = f[n-1] + f[n-2].<br>那么初始条件了，f[0] = f[1] = 1。<br>所以就变成了：f[n] = f[n-1] + f[n-2], 初始值f[0]=1, f[1]=1，目标求f[n]</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target; ++i)&#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
